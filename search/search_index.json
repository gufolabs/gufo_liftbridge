{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>It hides complex cluster topology management handling tasks and the internals of the gRPC as well.  Client offers following features:</p> <ul> <li>Publishing.</li> <li>Subscribing.</li> <li>Bulk publishing.</li> <li>Cursors manipulation.</li> <li>Cluster metadata fetching.</li> <li>Stream creating and destroying.</li> <li>Transparent data compression (own extension, may be not compatible with other clients).</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Clean async API.</li> <li>High-performance.</li> <li>Built with security in mind.</li> <li>Full Python typing support.</li> <li>Editor completion.</li> <li>Well-tested, battle-proven code.</li> </ul>"},{"location":"#on-gufo-stack","title":"On Gufo Stack","text":"<p>This product is a part of Gufo Stack - the collaborative effort  led by Gufo Labs. Our goal is to create a robust and flexible  set of tools to create network management software and automate  routine administration tasks.</p> <p>To do this, we extract the key technologies that have proven themselves  in the NOC and bring them as separate packages. Then we work on API, performance tuning, documentation, and testing. The NOC uses the final result as the external dependencies.</p> <p>Gufo Stack makes the NOC better, and this is our primary task. But other products can benefit from Gufo Stack too. So we believe that our effort will make  the other network management products better.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p> <p>To see unreleased changes, please see the CHANGELOG on the master branch guide.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>docs: Fancy front page</li> <li>docs: Supported standards page</li> <li>Liftrbridge context manager for tests</li> </ul>"},{"location":"CHANGELOG/#infrastructure","title":"Infrastructure","text":"<ul> <li>Ruff code linter</li> <li>Ruff formatter</li> <li>Move dependencies to pyproject.toml</li> <li>grpcio 1.74.0</li> <li>protobuf 6.32</li> <li>Use <code>actions/checkout@v4</code></li> <li>Use <code>actions/cache@v4</code></li> <li>Project structure tests</li> <li>CI workflows tests</li> <li>devcontainer: <code>settings</code> are moved to <code>customizations.vscode.settings</code></li> <li>use pypa/gh-action-pypi-publish@release/v1</li> <li>use actions/checkout@v4</li> <li>use actions/cache@v4</li> <li>use actions/setup-python@v5</li> </ul>"},{"location":"CHANGELOG/#010-2022-12-08","title":"0.1.0 - 2022-12-08","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Initial implementation</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2022-2025, Gufo Labs. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li>Redistributions of source code must retain the above copyright notice,    this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</li> <li>Neither the name of Gufo Labs nor the names of its contributors may be used    to endorse or promote products derived from this software without    specific prior written permission.</li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"faq/","title":"FAQ","text":"<p>What is \"Gufo\"?</p> <p>Gufo means the Owl in Italian.</p> <p>Why the owls?</p> <p>We love owls and the viable parts of our technologies were proven at the project, named \"the Owl\".</p> <p>What is \"Gufo Labs\"?</p> <p>Gufo Labs is the Milan-based company specialized on network and IT consulting, and on software research.</p> <p>What is \"Gufo Stack\"?</p> <p>We've extracted core components behind the NOC  and released them as independent packages, available under the terms  of the 3-clause BSD license. Our software shares common code quality standards  and is battle-proven under the high load. We hope our key components will help  the engineers and the developers to build reliable networks and robust network  management software.  See more for details.</p>"},{"location":"installation/","title":"Installation","text":"<p>Install with the pip</p> <pre><code>$ pip install gufo_liftbridge\n</code></pre>"},{"location":"installation/#checking-the-installation","title":"Checking the Installation","text":"<p>To check the installation just import the module</p> <pre><code>from gufo.liftbridge import liftbridge\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade existing Gufo liftbridge installation use pip</p> <pre><code>$ pip install --upgrade gufo_liftbridge\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<p>To uninstall Gufo liftbridge use pip</p> <pre><code>$ pip uninstall gufo_liftbridge\n</code></pre>"},{"location":"dev/","title":"Gufo Liftbridge: Developer's Guide","text":"<p>This section is intended for Gufo Liftbridge developers and for entities,  including both individuals and companies, interested in contributing to the project.</p> <ul> <li>Developer's Environment</li> <li>Building and Testing</li> <li>Common Tasks</li> <li>Code Quality</li> <li>Code Base</li> <li>Contributing Guide</li> <li>Code of Conduct</li> <li>Supported Standards</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"dev/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"dev/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"dev/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"dev/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"dev/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"dev/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"dev/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"dev/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"dev/CONTRIBUTING/","title":"Types of contributions","text":"<p>You can contribute to the Gufo Labs projects in several way. This repo is a place to discuss and collaborate on GitHub! Our team is maintaining this repo to preserve our bandwidth, off topic conversations will be closed.</p>"},{"location":"dev/CONTRIBUTING/#discussions","title":"Discussions","text":"<p>Discussions are where we have conversations.</p> <p>If you'd like help troubleshooting a PR you're working on, have a great new idea, or want to share something amazing you've learned in our docs, join us in discussions.</p>"},{"location":"dev/CONTRIBUTING/#issues","title":"Issues","text":"<p>Issues are used to track tasks that contributors can help with. </p> <p>If you've found bug, or something in the content of the documentation that should be updated, search open issues to see if someone else has reported the same thing. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p>"},{"location":"dev/CONTRIBUTING/#pull-requests","title":"Pull requests","text":"<p>A pull request is a way to suggest changes in our repository.</p>"},{"location":"dev/codebase/","title":"Project's Code Base","text":"<p>The code base of the project has following structure:</p> <ul> <li><code>.devcontainer/</code> - Developer's container configuration for    VSCode Remote Containers. Just reopen   project in remote container to get ready-to-development   environment.</li> <li> <p><code>.github/</code> - GitHub settings</p> <ul> <li><code>workflows/</code> - GitHub Actions Workflows settings.   Used to run tests and build the documentation.</li> </ul> </li> <li> <p><code>docs/</code> - Mkdocs documentation.</p> </li> <li><code>examples/</code> - Project's examples.</li> <li><code>src/</code> - Project's source code.</li> <li><code>tests/</code> - Project's Pytest test suite.</li> <li><code>.gitignore</code> - Gitignore file.</li> <li><code>Dockerfile</code> - Dockerfile for development container.</li> <li><code>mkdocs.yml</code> - Mkdocs configuration file.</li> <li><code>pyproject.toml</code> - pyproject.toml file for python tools configuration.</li> <li><code>setup.cfg</code> - Python library setup configuration.</li> </ul>"},{"location":"dev/codequality/","title":"Code Quality Guide","text":"<p>We share the common code quality standards between all Gufo Labs projects.</p>"},{"location":"dev/codequality/#python-code-formatting","title":"Python Code Formatting","text":"<p>All Python code must be formatting using ruff code formatter with settings defined in the project's <code>pyproject.toml</code> file.</p>"},{"location":"dev/codequality/#python-docstrings","title":"Python Docstrings","text":"<p>All Python functions and methods must be documenting using Google docstrings format.</p>"},{"location":"dev/codequality/#python-code-linting","title":"Python Code Linting","text":"<ul> <li>All Python code must satisfy PEP8 standards.</li> <li>Code must not contain unused imports.</li> <li>Code must not contain unused variables.</li> <li>Code must not use <code>l</code> variable or function names.</li> </ul> <p>All python code must pass ruff tests.</p>"},{"location":"dev/codequality/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>All python code must pass Mypy type checks in the <code>strict</code> mode.</p>"},{"location":"dev/codequality/#test-suite-coverage","title":"Test Suite Coverage","text":"<p>The test suite must provide 100% code coverage whenever possible.</p>"},{"location":"dev/codequality/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Documentation must be clean and mean.</li> </ul>"},{"location":"dev/common/","title":"Developer's Common  Tasks","text":""},{"location":"dev/common/#bump-version","title":"Bump Version","text":"<ul> <li> Change <code>__version__</code> in <code>src/gufo/liftbridge/__init__.py</code></li> <li> Add section in <code>CHANGELOG.md</code></li> </ul>"},{"location":"dev/common/#rebuild-grpc-api-stubs","title":"Rebuild gRPC API Stubs","text":"<p>From the development container</p> <pre><code>./tools/build-api.sh\n</code></pre>"},{"location":"dev/environment/","title":"Developer's Environment","text":"<p>To participate in development you need to prepare the developer's environment first. Depending on the preferable tools, your mileage may vary.</p>"},{"location":"dev/environment/#visual-studio-code-dev-container","title":"Visual Studio Code Dev Container","text":"<p>The easiest way to start the development is to use Visual Studio Code with Remote Containers plugin. Just click on the green sign in the lower-left corner and select the \"Reopen in Container\" menu item. You'll get all the required formatting and linting settings out of the box.</p>"},{"location":"dev/standards/","title":"Supported Standards","text":"<p>Gufo Liftbridge implements and is guided by the following standards:</p>"},{"location":"dev/standards/#python-pep","title":"Python PEP","text":"<ul> <li>PEP8: Style Guide for Python Code</li> <li>PEP561: Distributing and Packaging Type Information</li> </ul>"},{"location":"dev/testing/","title":"Building and Testing","text":"<p>Before starting building and testing package set up  Developer's Environment first. From here and below we consider the shell's current directory matches the project's root directory.</p>"},{"location":"dev/testing/#building-package","title":"Building Package","text":"<p>To test the package build run:</p> <pre><code>$ python -m build --sdist --wheel\n</code></pre> <p>Compiled packages will be available in the <code>dist/</code> directory.</p>"},{"location":"dev/testing/#running-tests","title":"Running tests","text":"<p>To run the test suit:</p> <pre><code>$ pytest -vv\n</code></pre>"},{"location":"dev/testing/#running-lints","title":"Running Lints","text":"<p>All lints are checked as part of GitHub Actions Workflow. You may run lints manually before committing to the project.</p>"},{"location":"dev/testing/#check-formatting","title":"Check Formatting","text":"<p>Python Code Formatting is the mandatory requirement in our Code Quality standards. To check code formatting run:</p> <pre><code>$ ruff format --check examples/ src/ tests/\n</code></pre> <p>To fix formatting errors run: <pre><code>$ ruff format examples/ src/ tests/\n</code></pre></p> <p>We recommend setting python code formatting on file saving (Done in VS Code Dev Container out of the box).</p>"},{"location":"dev/testing/#python-code-lints","title":"Python Code Lints","text":"<p>Python Code Linting is the mandatory requirement in our Code Quality standards. To check code for linting errors run:</p> <pre><code>$ ruff check examples/ src/ tests/\n</code></pre>"},{"location":"dev/testing/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>Python Code Static Checks is the mandatory requirement in our Code Quality standards. To check code for typing errors run:</p> <pre><code>$ mypy --strict src/\n</code></pre>"},{"location":"dev/testing/#python-test-code-coverage-check","title":"Python Test Code Coverage Check","text":"<p>To evaluate code coverage run tests:</p> <pre><code>$ coverage run -m pytest -vv\n</code></pre> <p>To report the coverage after the test run:</p> <pre><code>$ coverage report\n</code></pre> <p>To show line-by-line coverage:</p> <pre><code>$ coverage html\n</code></pre> <p>Then open <code>dist/coverage/index.html</code> file in your browser.</p>"},{"location":"dev/testing/#building-documentation","title":"Building Documentation","text":"<p>To rebuild and check documentation run</p> <pre><code>$ mkdocs serve\n</code></pre> <p>We recommend using Grammarly service to check documentation for common errors.</p>"},{"location":"examples/","title":"Gufo Liftbridge Examples","text":"<p>This part of the documentation contains a detailed explanation of the samples from the <code>examples/</code> folder.</p> <ul> <li>publish.py: Publishing.</li> <li>bulk.py: Bulk publishing.</li> <li>compression.py: Transparent Compression.</li> <li>subscribe.py: Subscribing.</li> <li>subcursor.py: Subscribing with cursor.</li> <li>create.py: Create Stream.</li> <li>delete.py: Delete Stream.</li> </ul>"},{"location":"examples/bulk/","title":"Gufo Liftbridge Example: Bulk Publishing","text":"<p>We have mastered the message publishing in our publish example. Synchronous publishing is a decent choice while the publishing rate remains moderate. But its performance is limited by the round-trip time (RTT). If the server responds in 1ms, you will have an overall limit of 1000 requests per second for a single publisher. Bulk publishing overrides an RTT limitation by separating request generation, sending, and acknowledgment.</p> <p>Note</p> <p>The stream and partition must be created before running the example, so refer to the Liftbridge Docs  or pass the create example.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>Let's see the details. </p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used.</p> <p>bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>publish()</code> function is <code>async def</code>.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>We have to prepare requests for bulk publishing. In our example we use the list comprehensions to build the list of 10 requests. Though we use list for our example, its possible to use any types of iterables, like generator functions and so on.</p> <p>Requests are created by <code>get_publish_request()</code> method. It accepts same parameters as the <code>publish()</code> method, but instead of immediate publishing returns the requests which can be passed to <code>publish_bulk()</code> later. The client does not enforce any specific data format and leaves it to the application. The only requirement is to pass the message value as the <code>bytes</code> type. In our example, we construct the string as the message and we have to encode it to the <code>bytes</code> manually. Then we must specify the stream and partition to publish, we use partition <code>0</code> of stream <code>test</code> in our example. It is possible to publish into diffent streams and partition in the one <code>publish_bulk()</code> call.</p> <p>Refer to the get_publish_request() reference for details.</p> <p>Now we're ready to publish our bulk.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>We use <code>publish_bulk()</code> method to send our prepared bulk of requests. The method is an asynchronous iterator, so it must be used with <code>async for</code> directive. It sends our bulk in one or more batch and yield the <code>Ack</code> for each request send. If the <code>wait</code> parameter is not set, method returns just after sending the last request and not waits for remaining acknowledgment which are in-flight. So the amount of <code>for</code> cycle iterations may be less than lenght of the bulk. This scenario is suitable for fire-and-forget tasks. It is up to application to control the acknowledgments and to deal the failures. In our example we just print them.</p> <p>Refer to the publish_bulk() reference for details.</p> bulk.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        bulk = [\n            client.get_publish_request(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n            for i in range(10)\n        ]\n        async for ack in client.publish_bulk(bulk, wait=True):\n            print(ack)\n\n\nasyncio.run(publish())\n</code></pre> <p>Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/compression/","title":"Gufo Liftbridge Example: Transparent Compression","text":"<p>We have mastered message publishing either in the  one-by-one (publish) or in the bulk (bulk) approaches. The bulk approach allows reaching much higher publishing rate, but what to do if your messages are large? Then we can hit the network bandwidth limitation. Gufo Liftbridge offers transparent message compression. It compresses the message before publishing and decompresses on receiving.</p> <p>Note</p> <p>Transparent message compression is the non-standard Gufo Liftbridge feature. It may not be compatible with other clients unless you manage it manually. Use it only when you are sure that publishers and subscribers are always using Gufo Liftbridge.</p> <p>Note</p> <p>The stream and partition must be created before running the example, so refer to the Liftbridge Docs  or pass the create example.</p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Let's see the details. </p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used.</p> <p>compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>publish()</code> function is <code>async def</code>.</p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. Unlike the publish example we added two options:</p> <ul> <li><code>compression_method</code>: must be <code>zlib</code> or <code>lzma</code>. Sets the algorithm   used when message compression is requested.</li> <li><code>compression_threshold</code>: sets the minimal size of message required   to compress them. <code>0</code> means compressing all messages.</li> </ul> <p>The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Let's publish 10 messages.</p> compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>The <code>publish()</code> function is used to publish one message immediately. The client does not enforce any specific data format and leaves it to the application. The only requirement is to pass the message value as the <code>bytes</code> type. In our example, we construct the string as the message and we have to encode it to the <code>bytes</code> manually. Then we must specify the stream and partition to publish, we use partition <code>0</code> of stream <code>test</code> in our example. Unlike the publish example we added <code>auto_compress</code> option. <code>auto_compress</code> instructs the client to compress the message if it falls beyond the threshold.</p> <p><code>publish()</code> is the async function and must be awaited. The function may accept additional parameters, so refer to the publish() referece for the detailed explanations.</p> <p>compression.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(\n        BROKERS, compression_method=\"lzma\", compression_threshold=0\n    ) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"),\n                stream=\"test\",\n                partition=0,\n                auto_compress=True,\n            )\n\n\nasyncio.run(publish())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/create/","title":"Gufo Liftbridge Example: Create Stream","text":"<p>The Liftridge's streams and partitions must be created before usage. Let's create the stream via LiftridgeClient.</p> create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> <p>Let's see the details. </p> create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used.</p> <p>create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>create()</code> function is <code>async def</code>.</p> create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> <p>We use the create_stream() function to create a stream <code>test</code> with one partition. By default, create_stream() doesn't wait until the partition is replicated via the cluster. The <code>wait_for_stream</code> parameter instructs to wait until the new stream is ready for use. The create_stream() is an async function and must be awaited.</p> <p>Refer to the create_stream() reference for the explanations.</p> <p>create.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def create():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.create_stream(\"test\", partitions=1, wait_for_stream=True)\n\n\nasyncio.run(create())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/delete/","title":"Gufo Liftbridge Example: Delete Stream","text":"<p>We have mastered the stream creation process in our create example. Now we'll learn how to delete a stream.</p> delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> <p>Let's see the details. </p> delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used.</p> <p>delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>delete()</code> function is <code>async def</code>.</p> delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> <p>We use the delete_stream() function to delete the <code>test</code> stream and all its partitions. The delete_stream() is an async function and must be awaited.</p> <p>delete.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def delete():\n    async with LiftbridgeClient(BROKERS) as client:\n        await client.delete_stream(\"test\")\n\n\nasyncio.run(delete())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/publish/","title":"Gufo Liftbridge Example: Publishing","text":"<p>The message queue has two fundamental operations: publishing and subscribing. Let's write the simple publisher. </p> <p>Note</p> <p>The stream and partition must be created before running the example, so refer to the Liftbridge Docs  or pass the create example.</p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Let's see the details. </p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used.</p> <p>publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>publish()</code> function is <code>async def</code>.</p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>Let's publish 10 messages.</p> publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> <p>The <code>publish()</code> function is used to publish one message immediately. The client does not enforce any specific data format and leaves it to the application. The only requirement is to pass the message value as the <code>bytes</code> type. In our example, we construct the string as the message and we have to encode it to the <code>bytes</code> manually. Then we must specify the stream and partition to publish, we use partition <code>0</code> of stream <code>test</code> in our example. <code>publish()</code> is the async function and must be awaited. The function may accept additional parameters, so refer to the publish() referece for the detailed explanations.</p> <p>publish.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def publish():\n    async with LiftbridgeClient(BROKERS) as client:\n        for i in range(10):\n            await client.publish(\n                f\"msg{i}\".encode(\"utf-8\"), stream=\"test\", partition=0\n            )\n\n\nasyncio.run(publish())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/subcursor/","title":"Gufo Liftbridge Example: Subscribing with Cursor","text":"<p>We have mastered the message subscription process in our subscribe example. We processed all the messages still stored in the partition. But what to do if the subscriber is restartable and we need to start from the first unprocessed message? Surely, we need to save the current position somewhere. It's up to the application where to store the position. In our example, we will use Liftbridge's cursors, the dedicated position storage just inside the Liftbridge  database.</p> <p>Note</p> <p>The stream and partition must be created before running the example, so refer to the Liftbridge Docs  or pass the create example.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>Let's see the details. </p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used. We also need the <code>StartPosition</code> enum.</p> <p>subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>Various subscribers may process the same partition in the same time, so multiple cursors on partition may exist. Each cursor has its own id. We use <code>test_cursor</code> for our example.</p> <p>subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>subscribe()</code> function is <code>async def</code>.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>The <code>subscribe()</code> method is used to receive the messages. We need to pass the stream (<code>test</code>), the partition (<code>0</code>), and the position from which to start receiving the messages. In our case, we use <code>StartPosition.RESUMEE</code> to resume the last position,  stored in the cursor. The cursor's id must be passed as the <code>cursor_id</code> parameter.</p> <p>The client implements subscribing as an async iterator, so the <code>async for</code> operator is usually used to iterate through. The result of iteration is the Message structure. The cycle is endless so it is up to the application to decide whenever to do the <code>break</code>.</p> <p>For additional parameters refer to the subscribe documentation.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>All following processing is built around the Message structure. It consists of several fields. Message body contained in the <code>value</code> attribute. The body is the raw <code>bytes</code> type and it's up to the application to handle them properly. We just use  <code>print()</code> to display the message body as well as the message's sequential number in the partition from the <code>offset</code> attribute.</p> subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> <p>After we processed the message we must store the message's offset into the cursor. <code>set_cursor</code> accepts the following parameters:</p> <ul> <li><code>stream</code>: The stream name.</li> <li><code>partition</code>: The partition.</li> <li><code>cursor_id</code>: The cursor's id.</li> <li><code>offset</code>: The current message offset.</li> </ul> <p>The function is asynchronous and must be awaited.</p> <p>subcursor.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\nCURSOR_ID = \"test_cursor\"\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\",\n            partition=0,\n            start_position=StartPosition.RESUME,\n            cursor_id=CURSOR_ID,\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n            await client.set_cursor(\n                \"test\", partition=0, cursor_id=CURSOR_ID, offset=msg.offset\n            )\n\n\nasyncio.run(subscribe())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"examples/subscribe/","title":"Gufo Liftbridge Example: Subscribing","text":"<p>We have mastered the message publishing process in our publish example. We also learned about various optimizations from bulk and compression. Now it is a time to learn about receiving messages. To get published messages we need to subscribe to the stream.</p> <p>Note</p> <p>The stream and partition must be created before running the example, so refer to the Liftbridge Docs  or pass the create example.</p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>Let's see the details. </p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>Gufo Liftbridge is an async library. In our case we should run the client from our synchronous script, so we need to import <code>asyncio</code> to use <code>asyncio.run()</code>.</p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>The client is implemented as a <code>LiftbridgeClient</code> class, which must be imported to be used. We also need the <code>StartPosition</code> enum.</p> <p>subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> Liftbridge is the dynamic cluster, synchronized over Raft protocol. Cluster members may enter and leave and the client uses one or more cluster members as a bootstrap to recover an actual topology. These bootstrap members are called <code>seeds</code> and are defined as a list of the strings in the <code>host:port</code> format. For our example, we consider the Liftbridge is running locally at the <code>127.0.0.1:9292</code>. Take note, ever we have one seed, we must define it as a list.</p> <p>subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> All async code must be performed in the <code>async</code> functions, so our <code>subscribe()</code> function is <code>async def</code>.</p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>We need an instance of the client. The instance may be used directly or operated as an async context manager with the <code>async with</code> clause. When used as a context manager, the client automatically closes all connections on the exit of context, so its lifetime is defined explicitly. <code>LiftbridgeClient</code> requires a list of seeds to connect the cluster, so we passed the <code>BROKERS</code> list. The client is highly configurable, refer to the LiftbridgeClient reference for the detailed explanations.</p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>The <code>subscribe()</code> method is used to receive the messages. We need to pass the stream (<code>test</code>), the partition (<code>0</code>), and the position from which to start receiving the messages. In our case, we use <code>StartPosition.EARLIEST</code> to receive all the messages still stored in the stream. To learn about other starting options refer to StartPosition documentation.</p> <p>The client implements subscribing as an async iterator, so the <code>async for</code> operator is usually used to iterate through. The result of iteration is the Message structure. The cycle is endless so it is up to the application to decide whenever to do the <code>break</code>.</p> <p>For additional parameters refer to the subscribe documentation.</p> subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> <p>All following processing is built around the Message structure. It consists of several fields. Message body contained in the <code>value</code> attribute. The body is the raw <code>bytes</code> type and it's up to the application to handle them properly. We just use  <code>print()</code> to display the message body as well as the message's sequential number in the partition from the <code>offset</code> attribute.</p> <p>subscribe.py<pre><code>import asyncio\nfrom gufo.liftbridge.client import LiftbridgeClient, StartPosition\n\nBROKERS = [\"127.0.0.1:9292\"]\n\n\nasync def subscribe():\n    async with LiftbridgeClient(BROKERS) as client:\n        async for msg in client.subscribe(\n            \"test\", partition=0, start_position=StartPosition.EARLIEST\n        ):\n            print(f\"{msg.offset}: {msg.value}\")\n\n\nasyncio.run(subscribe())\n</code></pre> Use <code>asyncio.run()</code> function to start our async code.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gufo.liftbridge<ul> <li>api_pb2</li> <li>api_pb2_grpc</li> <li>client</li> <li>compressor</li> <li>error</li> <li>liftbridge</li> <li>types</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/gufo/liftbridge/","title":"gufo.liftbridge","text":"<p>Gufo Liftbridge: Python Liftbridge Client.</p> <p>Attributes:</p> Name Type Description <code>__version__</code> <code>str</code> <p>Current version.</p>"},{"location":"reference/gufo/liftbridge/api_pb2/","title":"gufo.liftbridge.api_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/","title":"gufo.liftbridge.api_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.API","title":"<code>API</code>","text":"<p>               Bases: <code>object</code></p> <p>API is the main Liftbridge server interface clients interact with.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer","title":"<code>APIServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>API is the main Liftbridge server interface clients interact with.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.CreateStream","title":"<code>CreateStream(request, context)</code>","text":"<p>CreateStream creates a new stream attached to a NATS subject. It returns an AlreadyExists status code if a stream with the given subject and name already exists.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.DeleteStream","title":"<code>DeleteStream(request, context)</code>","text":"<p>DeleteStream deletes a stream.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.FetchConsumerGroupAssignments","title":"<code>FetchConsumerGroupAssignments(request, context)</code>","text":"<p>FetchConsumerGroupAssignments retrieves the partition assignments for a consumer. This also acts as a heartbeat for the consumer so that the coordinator keeps the consumer active in the group.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.FetchCursor","title":"<code>FetchCursor(request, context)</code>","text":"<p>FetchCursor retrieves a partition cursor position.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.FetchMetadata","title":"<code>FetchMetadata(request, context)</code>","text":"<p>FetchMetadata retrieves the latest cluster metadata, including stream broker information.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.FetchPartitionMetadata","title":"<code>FetchPartitionMetadata(request, context)</code>","text":"<p>FetchPartitionMetadata retrieves the latest partition metadata from partition leader The main interest is to retrieve Highest Watermark and Newest Offset</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.JoinConsumerGroup","title":"<code>JoinConsumerGroup(request, context)</code>","text":"<p>JoinConsumerGroup adds a consumer to a consumer group. If the group does not exist, it will create it first.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.LeaveConsumerGroup","title":"<code>LeaveConsumerGroup(request, context)</code>","text":"<p>LeaveConsumerGroup removes a consumer from a consumer group.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.PauseStream","title":"<code>PauseStream(request, context)</code>","text":"<p>PauseStream pauses a stream's partitions. If no partitions are specified, all of the stream's partitions will be paused. Partitions are resumed when they are published to via the Liftbridge Publish API.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.Publish","title":"<code>Publish(request, context)</code>","text":"<p>Publish a new message to a stream. If the AckPolicy is not NONE and a deadline is provided, this will synchronously block until the ack is received. If the ack is not received in time, a DeadlineExceeded status code is returned.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.PublishAsync","title":"<code>PublishAsync(request_iterator, context)</code>","text":"<p>PublishAsync is used to asynchronously publish messages to a stream in a pipelined fashion. This returns a stream which will yield PublishResponses for messages whose AckPolicy is not NONE.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.PublishToSubject","title":"<code>PublishToSubject(request, context)</code>","text":"<p>Publish a Liftbridge message to a NATS subject. If the AckPolicy is not NONE and a deadline is provided, this will synchronously block until the first ack is received. If an ack is not received in time, a DeadlineExceeded status code is returned.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.ReportConsumerGroupCoordinator","title":"<code>ReportConsumerGroupCoordinator(request, context)</code>","text":"<p>ReportConsumerGroupCoordinator reports a consumer group coordinator as failed. If a majority of the group's members report the coordinator within a bounded period, the cluster will select a new coordinator.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.SetCursor","title":"<code>SetCursor(request, context)</code>","text":"<p>SetCursor stores a cursor position for a particular stream partition which is uniquely identified by an opaque string.</p> <p>NOTE: This is a beta endpoint and is subject to change. It is not included as part of Liftbridge's semantic versioning scheme.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.SetStreamReadonly","title":"<code>SetStreamReadonly(request, context)</code>","text":"<p>SetStreamReadonly sets a read-only flag to a partition. Returns a NoSuchStream error code if the given stream or partition does not exist.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIServicer.Subscribe","title":"<code>Subscribe(request, context)</code>","text":"<p>Subscribe creates an ephemeral subscription for the given stream. It begins to receive messages starting at the given offset and waits for new messages when it reaches the end of the stream. Use the request context to close the subscription.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIStub","title":"<code>APIStub</code>","text":"<p>               Bases: <code>object</code></p> <p>API is the main Liftbridge server interface clients interact with.</p>"},{"location":"reference/gufo/liftbridge/api_pb2_grpc/#gufo.liftbridge.api_pb2_grpc.APIStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required"},{"location":"reference/gufo/liftbridge/client/","title":"gufo.liftbridge.client","text":"<p>Python Liftbridge client.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <p>Client logger.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel","title":"<code>GRPCChannel</code>","text":"<p>               Bases: <code>object</code></p> <p>gRPC channel wrapper. Wraps connection to broker.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>str</code> <p>target address in form \":\". required"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Context manager enter.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel.__aexit__","title":"<code>__aexit__(exc_type, exc, traceback)</code>  <code>async</code>","text":"<p>Context management exit.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Get wrapped API method.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close channel connection.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.GRPCChannel.connect","title":"<code>connect(max_message_size=DEFAULT_MAX_MESSAGE_SIZE, enable_http_proxy=False)</code>  <code>async</code>","text":"<p>Connect channel.</p> <p>Parameters:</p> Name Type Description Default <code>max_message_size</code> <code>int</code> <p>Maximal size of message.</p> <code>DEFAULT_MAX_MESSAGE_SIZE</code> <code>enable_http_proxy</code> <code>bool</code> <p>Enable usage of HTTP proxies.</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient","title":"<code>LiftbridgeClient</code>","text":"<p>               Bases: <code>object</code></p> <p>Asynchronous Liftbridge client.</p> <p>Parameters:</p> Name Type Description Default <code>brokers</code> <code>Iterable[str]</code> <p>Iterable of stings containning hints to cluster members, either as FQDN or in <code>&lt;address&gt;:&lt;port&gt;</code> format.</p> required <code>max_message_size</code> <code>int</code> <p>Maximal size of message in octets.</p> <code>DEFAULT_MAX_MESSAGE_SIZE</code> <code>enable_http_proxy</code> <code>bool</code> <p>Enable usage of HTTP proxies.</p> <code>False</code> <code>compression_method</code> <code>Optional[str]</code> <p>Enable message compression.</p> <code>None</code> <code>compression_threshold</code> <code>int</code> <p>Works only if <code>compression_method</code> is set. Do not compress messages with size below the <code>compression_threshold</code>.</p> <code>0</code> <code>encoding_header</code> <code>str</code> <p>Header name to pass <code>compression_method</code> when message is compressed.</p> <code>'X-Msg-Encoding'</code> <code>publish_async_ack_timeout</code> <code>float</code> <code>10.0</code> <code>metadata_leader_timeout</code> <code>float</code> <p>Mean timeout on <code>no metadata leader</code> error.</p> <code>3.0</code> <code>metadata_leader_dev</code> <code>float</code> <p>Deviation of timeout on <code>no metadata leader</code> error.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters are incorrect.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Entering context manager.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.__aexit__","title":"<code>__aexit__(exc_type, exc, traceback)</code>  <code>async</code>","text":"<p>Exit from context manager.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close all open channels.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.create_stream","title":"<code>create_stream(name, *, subject=None, group=None, replication_factor=1, minisr=0, partitions=1, enable_compact=False, retention_max_age=0, retention_max_bytes=0, segment_max_age=0, segment_max_bytes=0, auto_pause_time=0, auto_pause_disable_if_subscribers=False, wait_for_stream=False)</code>  <code>async</code>","text":"<p>Create stream. Internal implementation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Stream name.</p> required <code>subject</code> <code>Optional[str]</code> <p>Optional NATS subject.</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>???</p> <code>None</code> <code>replication_factor</code> <code>int</code> <p>Replication factor, amount of cluster members to replicate each partition.</p> <code>1</code> <code>minisr</code> <code>int</code> <p>Minimum in-service replicas.</p> <code>0</code> <code>partitions</code> <code>int</code> <p>Number of partition in the stream.</p> <code>1</code> <code>enable_compact</code> <code>bool</code> <p>Enable stream compaction.</p> <code>False</code> <code>retention_max_age</code> <code>int</code> <p>???</p> <code>0</code> <code>retention_max_bytes</code> <code>int</code> <p>???</p> <code>0</code> <code>segment_max_age</code> <code>int</code> <p>???</p> <code>0</code> <code>segment_max_bytes</code> <code>int</code> <p>???</p> <code>0</code> <code>auto_pause_time</code> <code>int</code> <p>???</p> <code>0</code> <code>auto_pause_disable_if_subscribers</code> <code>bool</code> <p>???</p> <code>False</code> <code>wait_for_stream</code> <code>bool</code> <p>Wait until the stream is really created.</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.delete_stream","title":"<code>delete_stream(name)</code>  <code>async</code>","text":"<p>Delete streeam.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Stream name.</p> required"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.get_cursor","title":"<code>get_cursor(stream, partition, cursor_id)</code>  <code>async</code>","text":"<p>Fetch current partition cursor position.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>Stream name.</p> required <code>partition</code> <code>int</code> <p>Partition numbers.</p> required <code>cursor_id</code> <code>str</code> <p>Cursor identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Current cursor position. -1 for the new cursor.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.get_metadata","title":"<code>get_metadata(stream=None, *, wait_for_stream=False)</code>  <code>async</code>","text":"<p>Get cluster metadata.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>Optional[str]</code> <p>Fetch metadata only for particular stream, if set.</p> <code>None</code> <code>wait_for_stream</code> <code>bool</code> <p>Wait until stream will be created.</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.get_partition_metadata","title":"<code>get_partition_metadata(stream, partition, wait_for_stream=False)</code>  <code>async</code>","text":"<p>Fetch metadata for particular partition.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>Stream name.</p> required <code>partition</code> <code>int</code> <p>Partitionn number.</p> required <code>wait_for_stream</code> <code>bool</code> <p>If set, wait for stream being available.</p> <code>False</code> <p>Returns:</p> Type Description <code>PartitionMetadata</code> <p>Partition metadata.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.get_publish_request","title":"<code>get_publish_request(value, *, stream=None, key=None, partition=None, headers=None, ack_inbox=None, correlation_id=None, ack_policy=AckPolicy.LEADER, auto_compress=False)</code>","text":"<p>Generate PublishRequest for bulk operations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes</code> <p>Message body.</p> required <code>stream</code> <code>Optional[str]</code> <p>Stream to publish.</p> <code>None</code> <code>key</code> <code>Optional[bytes]</code> <p>Optional message key.</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>Partition.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, bytes]]</code> <p>Message headers.</p> <code>None</code> <code>ack_inbox</code> <code>Optional[str]</code> <p>Optional inbox to send acknowledge.</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>Opaque id to correlate messages.</p> <code>None</code> <code>ack_policy</code> <code>AckPolicy</code> <p>Acknowledgement policies.</p> <code>LEADER</code> <code>auto_compress</code> <code>bool</code> <p>If <code>True</code> compress value if the client's <code>compression_method</code> is set and the size of value is beyound <code>compression_threshold</code>.</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.publish","title":"<code>publish(value, *, stream=None, key=None, partition=None, headers=None, ack_inbox=None, correlation_id=None, ack_policy=AckPolicy.LEADER, wait_for_stream=False, auto_compress=False)</code>  <code>async</code>","text":"<p>Publish single message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes</code> <p>bytes,</p> required <code>stream</code> <code>Optional[str]</code> <p>Optional[str] = None,</p> <code>None</code> <code>key</code> <code>Optional[bytes]</code> <p>Optional[bytes] = None,</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>Optional[int] = None,</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, bytes]]</code> <p>Optional[Dict[str, bytes]] = None,</p> <code>None</code> <code>ack_inbox</code> <code>Optional[str]</code> <p>Optional[str] = None,</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>Optional[str] = None,</p> <code>None</code> <code>ack_policy</code> <code>AckPolicy</code> <p>AckPolicy = AckPolicy.LEADER,</p> <code>LEADER</code> <code>wait_for_stream</code> <code>bool</code> <p>bool = False,</p> <code>False</code> <code>auto_compress</code> <code>bool</code> <p>bool = False,</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.publish_bulk","title":"<code>publish_bulk(iter_req, wait=True)</code>  <code>async</code>","text":"<p>Bulk publishing from iterator.</p> <p>Parameters:</p> Name Type Description Default <code>iter_req</code> <code>Iterable[PublishRequest]</code> <p>Iterable of PublishRequest.</p> required <code>wait</code> <code>bool</code> <p>Wait for all acks if set to <code>True</code>.</p> <code>True</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.set_cursor","title":"<code>set_cursor(stream, partition, cursor_id, offset)</code>  <code>async</code>","text":"<p>Save cursor position for partition.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>Stream name.</p> required <code>partition</code> <code>int</code> <p>Partition number.</p> required <code>cursor_id</code> <code>str</code> <p>Cursor identifier.</p> required <code>offset</code> <code>int</code> <p>Cursor offset to save.</p> required"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.subscribe","title":"<code>subscribe(stream, *, partition=None, start_position=StartPosition.NEW_ONLY, start_offset=None, start_timestamp=None, resume=False, cursor_id=None, timeout=None, allow_isr=False)</code>  <code>async</code>","text":"<p>Subscribe to partition.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>Stream name.</p> required <code>partition</code> <code>Optional[int]</code> <p>Stream partition.</p> <code>None</code> <code>start_position</code> <code>StartPosition</code> <p>Starting position. See <code>StartPosition</code> for details.</p> <code>NEW_ONLY</code> <code>start_offset</code> <code>Optional[int]</code> <p>Starting offset, if <code>start_position</code> is <code>OFFSET</code></p> <code>None</code> <code>start_timestamp</code> <code>Optional[float]</code> <p>Starting timestamp, if <code>start_position</code> is <code>TIMESTAMP</code></p> <code>None</code> <code>resume</code> <code>bool</code> <p>Resume start position.</p> <code>False</code> <code>cursor_id</code> <code>Optional[str]</code> <p>Cursor ID to resume, if <code>start_position</code> is <code>RESUME</code>.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Optional timeout in seconds.</p> <code>None</code> <code>allow_isr</code> <code>bool</code> <p>Allow connections to in-state replicas (ISR).</p> <code>False</code>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.wait_for_cursors","title":"<code>wait_for_cursors()</code>  <code>async</code>","text":"<p>Wait until cursors become available.</p>"},{"location":"reference/gufo/liftbridge/client/#gufo.liftbridge.client.LiftbridgeClient.wait_for_stream","title":"<code>wait_for_stream(stream)</code>  <code>async</code>","text":"<p>Wait until stream become availabble.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>Stream name</p> required"},{"location":"reference/gufo/liftbridge/compressor/","title":"gufo.liftbridge.compressor","text":"<p>Compressor implementations.</p>"},{"location":"reference/gufo/liftbridge/compressor/#gufo.liftbridge.compressor.compress","title":"<code>compress(value, method)</code>","text":"<p>Compress <code>value</code> with given <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes</code> <p>Uncompressed value.</p> required <code>method</code> <code>str</code> <p>Compression method, one of: <code>zlib</code>, <code>lzma</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Compressed value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On invalid <code>method</code>.</p>"},{"location":"reference/gufo/liftbridge/compressor/#gufo.liftbridge.compressor.decompress","title":"<code>decompress(value, method)</code>","text":"<p>Decompress <code>value</code> with given <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes</code> <p>Compressed value.</p> required <code>method</code> <code>str</code> <p>Compression method, one of: <code>zlib</code>, <code>lzma</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Decompressed value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On invalid <code>method</code>.</p>"},{"location":"reference/gufo/liftbridge/error/","title":"gufo.liftbridge.error","text":"<p>Errors definitions.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorAlreadyExists","title":"<code>ErrorAlreadyExists</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>Partition is already exists.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorChannelClosed","title":"<code>ErrorChannelClosed</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>Channel is terminated by broker.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorMessageSizeExceeded","title":"<code>ErrorMessageSizeExceeded</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>Message size exceeds allowed limit.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorNoMetadataLeader","title":"<code>ErrorNoMetadataLeader</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>No known metadata leader.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorNotFound","title":"<code>ErrorNotFound</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>Unable to resolve broker.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.ErrorUnavailable","title":"<code>ErrorUnavailable</code>","text":"<p>               Bases: <code>LiftbridgeError</code></p> <p>Broker is not available.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.LiftbridgeError","title":"<code>LiftbridgeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for LirtBridgeClient errors.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.rpc_error","title":"<code>rpc_error</code>","text":"<p>               Bases: <code>object</code></p> <p>Context manager to process RPC errors.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.rpc_error.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter context.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.rpc_error.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit context handler.</p>"},{"location":"reference/gufo/liftbridge/error/#gufo.liftbridge.error.is_no_metada_leader","title":"<code>is_no_metada_leader(exc)</code>","text":"<p>Check if the error is <code>no known metadata leader</code>.</p>"},{"location":"reference/gufo/liftbridge/liftbridge/","title":"gufo.liftbridge.liftbridge","text":"<p>liftbridge context manager.</p>"},{"location":"reference/gufo/liftbridge/liftbridge/#gufo.liftbridge.liftbridge.Liftbridge","title":"<code>Liftbridge</code>","text":"<p>               Bases: <code>object</code></p> <p>Liftbridge context manager for testing.</p> Example <pre><code>with Lifrbridge():\n    # Any liftbridge code\n</code></pre>"},{"location":"reference/gufo/liftbridge/liftbridge/#gufo.liftbridge.liftbridge.Liftbridge.broker","title":"<code>broker</code>  <code>property</code>","text":"<p>Current brocker.</p>"},{"location":"reference/gufo/liftbridge/liftbridge/#gufo.liftbridge.liftbridge.Liftbridge.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p>"},{"location":"reference/gufo/liftbridge/liftbridge/#gufo.liftbridge.liftbridge.Liftbridge.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p>"},{"location":"reference/gufo/liftbridge/liftbridge/#gufo.liftbridge.liftbridge.Liftbridge.get_config","title":"<code>get_config()</code>","text":"<p>Get service config.</p>"},{"location":"reference/gufo/liftbridge/types/","title":"gufo.liftbridge.types","text":"<p>Types definitions.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.AckPolicy","title":"<code>AckPolicy</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Publish acknowledgment policy.</p> <p>Attributes:</p> Name Type Description <code>LEADER</code> <p>Wait for acknowledgment from a leader.</p> <code>ALL</code> <p>Wait for acknowledgment from all cluster members.</p> <code>NONE</code> <p>Do not wait for an acknowledgment.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.Broker","title":"<code>Broker</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Broker node metadata.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Broker id.</p> <code>host</code> <code>str</code> <p>Broker host.</p> <code>port</code> <code>int</code> <p>Broker port.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Liftbridge message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes</code> <p>Message body.</p> required <code>subject</code> <code>str</code> <p>Message stream.</p> required <code>offset</code> <code>int</code> <p>Message offset.</p> required <code>timestamp</code> <code>int</code> <p>Message timestamp in UNIX format.</p> required <code>key</code> <code>bytes</code> <p>Message key.</p> required <code>partition</code> <code>int</code> <p>stream partition.</p> required <code>headers</code> <code>Dict[str, bytes]</code> <p>Additional message headers.</p> required"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.Metadata","title":"<code>Metadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Liftbridge cluster metadata.</p> <p>Attributes:</p> Name Type Description <code>brockers</code> <p>List of brokers.</p> <code>metadata</code> <code>List[StreamMetadata]</code> <p>List of stream's metadata.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.PartitionMetadata","title":"<code>PartitionMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Partition metadata.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Partition id.</p> <code>leader</code> <code>str</code> <p>Leader broker id.</p> <code>replicas</code> <code>List[str]</code> <p>Replica nodes.</p> <code>isr</code> <code>List[str]</code> <code>high_watermark</code> <code>int</code> <p>Highest uncommited offset in partition.</p> <code>newest_offset</code> <code>int</code> <p>Offset for the next record.</p> <code>paused</code> <code>bool</code> <p>Partition is paused.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.RetentionPolicy","title":"<code>RetentionPolicy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Partition's retention policy.</p> <p>Attributes:</p> Name Type Description <code>retention_bytes</code> <code>int</code> <p>Keep up to <code>retention_bytes</code> in a partition.</p> <code>segment_bytes</code> <code>int</code> <code>retention_ages</code> <code>int</code> <code>segment_ages</code> <code>int</code>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.StartPosition","title":"<code>StartPosition</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Subscriber's start position.</p> <p>Attributes:</p> Name Type Description <code>NEW_ONLY</code> <p>Start from new messages beyond the latest published.</p> <code>OFFSET</code> <p>Start at a specified offset.</p> <code>EARLIEST</code> <p>Start at the oldest message remaining in a partition.</p> <code>LATEST</code> <p>Start with the newest message.</p> <code>TIMESTAMP</code> <p>Start from a specified timestamp.</p> <code>RESUME</code> <p>Non-standard. Resume from next to last processed.</p>"},{"location":"reference/gufo/liftbridge/types/#gufo.liftbridge.types.StreamMetadata","title":"<code>StreamMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Stream metadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Stream name.</p> <code>subject</code> <code>str</code> <p>Stream subject.</p> <code>partitions</code> <code>Dict[int, PartitionMetadata]</code> <p>List of partitions metadata.</p>"},{"location":"reference/gufo/liftbridge/utils/","title":"gufo.liftbridge.utils","text":"<p>Various utilities.</p>"},{"location":"reference/gufo/liftbridge/utils/#gufo.liftbridge.utils.is_ipv4","title":"<code>is_ipv4(addr)</code>","text":"<p>Check value is valid IPv4 address.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>String to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code>, if is valid IPv4 address. <code>False</code> otherwise.</p>"}]}